use lazy_static::lazy_static;

use clap::Args;

use crate::common::{ObjectHeader, ObjectModule, RefEntry, RelEntry, SymEntry};

mod linker;

/*
lazy_static! {
    #[rustfmt::skip]
    static ref r2k_startup_obj: ObjectModule = ObjectModule {
        head: ObjectHeader {
            magic: 0xface,
            version: 0x2cc6,
            flags: 0x00000000,
            entry: 0x00000000,
            data: [
                0x00000040, 0x00000000, 0x00000008, 0x00000000, 0x00000000, 0x00000003, 0x00000006,
                0x0000003D, 0x00000000, 0x00000000,
            ]
        },
        text: vec![
        0x34, 0x02, 0x00, 0x09, 0x34, 0x04, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x0c, 0x3c, 0x08, 0x00, 0x00,
        0x35, 0x08, 0x00, 0x00, 0xad, 0x02, 0x00, 0x00,
        0x3c, 0x08, 0x00, 0x00, 0x35, 0x08, 0x00, 0x00,
        0xad, 0x02, 0x00, 0x00, 0x8f, 0xa4, 0x00, 0x00,
        0x8f, 0xa5, 0x00, 0x04, 0x8f, 0xa6, 0x00, 0x08,
        0x0c, 0x00, 0x00, 0x00, 0x00, 0x40, 0x20, 0x21,
        0x34, 0x02, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x0c,
        ],
        rdata: vec![],
        data: vec![
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ],
        sdata: vec![],
        rel_info: vec![],
        ext_ref: vec![
        0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x13, 0x00, 0x03, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x03, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x05, 0x00, 0x00,
        ],
        symtab: vec![
        0x00, 0x00, 0x40, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x05, 0x00, 0x00,
        0x00, 0x00, 0x40, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x04, 0x00, 0x6c, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x04, 0x00, 0x6c, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xa2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00,
        ],
        strtab: vec![
            "SYS_EXIT2", "SYS_SBRK", "__heap_ptr", "__heap_size", "main", "__r2k_entry"
        ].into_iter()
        .flat_map(|s| s.chars().map(|c| c as u8).chain([0].into_iter()))
        .collect(),
    };
}
*/

#[derive(Args, Clone)]
#[command(
    about = "Link one or more object modules produced by rasm or rlink into one executable
"
)]
pub struct LinkerArgs {
    #[arg(
        short = 'm',
        help = "Print a load map showing the relocated addresses of all symbols defined in the object modules being linked."
    )]
    load_map: bool,
    #[arg(
        short = 'o',
        help = "Use this as the name of the load module to be created. The default name is determined by the object module which contains the entry point main; if none is found and no -o option is given, r.out is used."
    )]
    out: Option<String>,
    #[arg(
        short = 's',
        help = "Use the specified file as the startup routine. By default an internal object is used"
    )]
    startup: Option<String>,
    files: Vec<String>,
}

pub fn link(args: &LinkerArgs) {
    let mut objs = vec![];

    for f in &args.files {
        objs.push(ObjectModule::from_slice_u8(&std::fs::read(f).unwrap()).unwrap());
    }

    let out = crate::link::linker::link(objs, args);
}
